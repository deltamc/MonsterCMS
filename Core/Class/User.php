<?php namespace Monstercms\Core;

defined('MCMS_ACCESS') or die('No direct script access.');

class User
{
    /**
     * @var \Monstercms\Lib\DataBase;
     */
    protected static $db;
    protected static $usersTable;
    protected static $usersDataTable;

    //Данные авторизированного пользователя
    protected static $userData;
    protected static $login;
    protected static $password;
    protected static $hash;
    protected static $id;

    protected static function int()
    {
        if(self::$db === null){
            self::$db = Mcms::DB();
        }

        if(self::$usersTable === null){
            self::$usersTable = DB_TABLE_USERS;
        }

        if(self::$usersTable === null){
            self::$usersDataTable = DB_TABLE_USERS_DATA;
        }



    }

    /**
     * @param $password
     * @param int $cost
     * @return string
     */
    static function generateHash($password, $cost=11)
    {
        /* To generate the salt, first generate enough random bytes. Because
         * base64 returns one character for each 6 bits, the we should generate
         * at least 22*6/8=16.5 bytes, so we generate 17. Then we get the first
         * 22 base64 characters
         */
        $salt=substr(base64_encode(self::randomToken(17)), 0, 22);
        /* As blowfish takes a salt with the alphabet ./A-Za-z0-9 we have to
         * replace any '+' in the base64 string with '.'. We don't have to do
         * anything about the '=', as this only occurs when the b64 string is
         * padded, which is always after the first 22 characters.
         */
        $salt=str_replace("+", ".", $salt);
        /* Next, create a string that will be passed to crypt, containing all
         * of the settings, separated by dollar signs
         */
        $param='$'.implode('$', array(
                "2y", //select the most secure version of blowfish (>=PHP 5.3.7)
                str_pad($cost, 2, "0", STR_PAD_LEFT), //add the cost in two digits
                $salt //add the salt
            ));

        //now do the actual hashing
        return crypt($password, $param);
    }

    /*
        * Check the password against a hash generated by the generate_hash
        * function.
    */

    function validatePw($password, $hash){
        /* Regenerating the with an available hash as the options parameter should
         * produce the same hash if the same password is passed.
         */
        return crypt($password, $hash)==$hash;
    }

    protected static function randomToken($length = 32)
    {
        if(!isset($length) || intval($length) <= 8 ){
            $length = 32;
        }
        if (function_exists('random_bytes')) {
            return bin2hex(random_bytes($length));
        }
        if (function_exists('mcrypt_create_iv')) {
            return bin2hex(mcrypt_create_iv($length, MCRYPT_DEV_URANDOM));
        }
        if (function_exists('openssl_random_pseudo_bytes')) {
            return bin2hex(openssl_random_pseudo_bytes($length));
        }

        $chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHI JKLMNOPRQSTUVWXYZ0123456789";
        $code  = "";
        $clen  = strlen($chars) - 1;

        while (strlen($code) < $length) {

            $code .= $chars[mt_rand(0, $clen)];
        }

        return $code;
    }

    /*
     * Check the password against a hash generated by the generate_hash
     * function.
    */
    public static function passwordVerify($password, $hash){

        if (function_exists('hash_equals')) {
            return hash_equals($password, crypt($password, $hash));
        }

        return crypt($password, $hash) === $hash;
    }

    /**
     * Метод проверяет есть ли пользователь с заданным логином
     * @param $login - логин
     * @param null $ignoreId - не учитывать пользователя с ид
     * @return bool
     */
    public function isUserByLogin($login, $ignoreId = null)
    {
        self::int();

        $table = self::$usersTable;
        $sql = "SELECT id FROM {$table} WHERE `login`= ?";

        if ($ignoreId !== null) {
            $sql .= ' AND id <> ' . intval($ignoreId);
        }

        $stmt = self::$db->prepare($sql);
        $stmt->execute(array($login));
        $result = $stmt->fetchColumn();

        if (!$result) {
           return false;
        }

        return true;
    }

    /**
     * Метод устанавливает данные пользователя.
     *
     * @param $hash
     * @return bool
     */
    public static function setData($hash)
    {
        $table = self::$usersTable;
        $sql = "SELECT id FROM {$table} WHERE `hash`= ?";
        $stmt = self::$db->prepare($sql);
        $stmt->execute(array($hash));
        $result = $stmt->fetch();

        if (!$result) {
            return false;
        }


        self::$login    = $result['login'];
        self::$password = $result['password'];
        self::$hash     = $result['hash'];
        self::$id       = $result['id'];

        self::setProperties(self::$id);

        return true;
    }

    /**
     * Метод считывает свойства пользователя из бд     *
     * @param $userId
     * @return bool
     */
    protected static function setProperties($userId)
    {
        $table = self::$usersDataTable;
        $sql = "SELECT id FROM {$table} WHERE `id_user`= ?";
        $stmt = self::$db->prepare($sql);
        $stmt->execute(array($userId));
        $properties = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        if (!$properties) {
            return false;
        }

        self::$userData = $properties;
    }

    /**
     * Метод обновляет хеш
     * @param $userId
     * @throws \Exception
     */
    protected static function updateHash($userId)
    {
        $hash   = md5(self::randomToken());
        $list   = array('hash' => $hash);
        $userId = (int) $userId;
        $table  = self::$usersTable;

        self::$db->update($list, $table, $userId);
    }


    protected static function authorization($login, $password)
    {
        $password = self::generateHash($password);

        $login = escapeString($login);

        $sql = "SELECT `id`, `name`, `login` FROM `user` WHERE `login` = ? AND `password` = ?";

        $this->user = getAssocResultOne($sql);

        if (!empty($this->user)) {
            session_start();
            $_SESSION[$this->sessionKey]['id']         = $this->user['id'];
            $_SESSION[$this->sessionKey]['name']       = $this->user['name'];
            $_SESSION[$this->sessionKey]['login']      = $this->user['login'];
            $_SESSION[$this->sessionKey]['user_agent'] = $_SERVER['HTTP_USER_AGENT'];

            return true;
        }

        return false;
    }



    public static function isAdmin()
    {
        return true;
    }
}